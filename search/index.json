[{"content":"Sliding Window使用左右指針將搜尋區間固定住，最佳的應用例子是可以把搜尋的時間複雜度維持在線性。 實作上的基本概念就是在每次檢查針對題目要求更新window的大小。\n🚀 實例 這次選了兩道medium難度的題目，分別是 #3 (Longest Substring Without Repeating Characters) 以及 #438 (Find All Anagrams in a String)\n3. Longest Substring Without Repeating Characters 找出字串s中最長的不重複子字串。舉例來說，\n  Input: s = \u0026ldquo;abcabcbb\u0026rdquo; Output: 3 Input: s = \u0026ldquo;bbbbb\u0026rdquo; Output: 1 Input: s = \u0026ldquo;pwwkew\u0026rdquo; Output: 3 Input: s = \u0026ldquo;aab\u0026rdquo; Output: 2 Input: s = \u0026ldquo;dvdf\u0026rdquo; Output: 3 Input: s = \u0026ldquo;qrsvbspk\u0026rdquo; Output: 5 Input: s = \u0026ldquo;aabaab!bb\u0026rdquo; Output: 3   (有這麼多例子，就是因為我實在錯太多次了QQ)\n演算法概念 我們可以利用兩個pointer指向window的左邊端點與右邊端點，並以集合的方式來檢查是否window中有重複的元素。\n 如果沒有，就繼續把window擴大，同時取最長子字串長度len=max(set.size, len)。 有的話，window得更新範圍，與此同時，集合當中的元素也要更新。更新的方法其實就是如果有重複，就把==重複的元素當中比較舊的==那個給移除掉。 :::warning 要注意的是，不僅僅是將左端點s[l]刪除，假設今天s[r]是與s[l*]重複，那從s[l]到s[l*]的元素都要從集合中刪掉!! :::  以上面第一個例子來演練一次的話，完整過程就會如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  s = \u0026#34;abcabcbb\u0026#34; lr len=1(a) l r len=2(a,b) l r len=3(a,b,c) -\u0026gt; 此時s[r]重複(a)，將左邊的a移除 s = \u0026#34;abcabcbb\u0026#34; l r len=3(b,c,a) l r len=3(b,c,a) -\u0026gt; 此時s[r]重複(b)，將左邊的b移除 s = \u0026#34;abcabcbb\u0026#34; l r len=3(c,a,b) l r len=3(c,a,b) -\u0026gt; 此時s[r]重複(c)，將左邊的c移除 s = \u0026#34;abcabcbb\u0026#34; l r len=3(a,b,c) l r len=3(a,b,c) -\u0026gt; 此時s[r]重複(b)，將左邊的a,b移除 s = \u0026#34;abcabcbb\u0026#34; lr len=3(c,b) l r len=3(c,b) -\u0026gt; 此時s[r]重複(b)，將左邊的c,b移除 s = \u0026#34;abcabcbb\u0026#34; l r len=3(b) *end*   (放了很多次s字串，只是方便閱讀比對位置而已)\n程式實作 驗證過概念上沒問題了之後，實作的C++程式如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int lengthOfLongestSubstring(string s) { set\u0026lt;char\u0026gt; chars; int l = 0, r = 1; chars.insert(s[l]); int len = chars.size(); if (s.length() == 0) return 0; while (r \u0026lt; s.length()) { if (chars.find(s[r]) == chars.end()) { chars.insert(s[r]); len = chars.size() \u0026gt; len ? chars.size() : len; r += 1; } else { // remove all char before duplicated char  while (s[l] != s[r]) { chars.erase(s[l]); l += 1; } chars.erase(s[l]); l += 1; } } return len; }   438. Find All Anagrams in a String 提供兩個字串s、p，回傳所有符合p是s的anagram的index。\n Anagram意思指僅使用一次包含的所有字元的排列組合。如以下例子 Input: s = \u0026ldquo;cbaebabacd\u0026rdquo;, p = \u0026ldquo;abc\u0026rdquo; Output: [0,6] [0-2]的\u0026quot;cba\u0026quot;是p的anagram，而[6-8]的\u0026quot;bac\u0026quot;也是p的anagram。\n 演算法概念 一開始想到的方法，除了暴力法外，若想要把搜尋限制在線性，我想到可以用sliding window+數數的方法。 也就是說，因為在此題中，s, p限制了內容只會是小寫字母，因此我們可以直接使用一個map將26個字母的數量存起來。同樣的，使用l+r指標，框住目前的window，使用r指標依序檢查s[r]是否有在p map當中，有的話那就減一，但如果扣到\u0026lt;0，跟p字串不存在這個字母的情況一樣，那就移到下一個window檢查，也就是l+=1。\n當p的這個map每個字母都扣完了，代表目前這個window就是我們要找的anagram。\n程式實作 pMap代表p字串中各個字母的數量。pTotal是pMap的總和，一開始pTotal==p.size()。 pM與pT是每個window的比較基準，因為每個符合的window都是anagram of p。pM與pT是從原本的pMap, pTotal copy過來的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { vector\u0026lt;int\u0026gt; indexs; if(s.size()==0) return indexs; int pMap[26] = {0}; int pTotal=p.size(); for(int i=0; i\u0026lt;p.size(); i++) { pMap[p[i]-\u0026#39;a\u0026#39;]+=1; } int l=0, r=0; for(int l=0; l\u0026lt;s.size(); l++) { int r=l, pT=pTotal; int pM[26]; memcpy(pM, pMap, 26*sizeof(int)); while(r\u0026lt;s.size() \u0026amp;\u0026amp; --pM[s[r]-\u0026#39;a\u0026#39;]\u0026gt;=0) { pT-=1; if(pT==0) { indexs.push_back(l); } r+=1; } } return indexs; }   小結 使用兩個題目來解釋sliding window的概念，希望能幫助到也感到困惑的人。也提醒自己不要忘了主要的重點：使用l,r固定住檢查範圍，在每次檢查針對題目要求更新window的大小。\n","date":"2022-02-03T14:54:57+01:00","permalink":"https://miyaya.github.io/p/sliding-window-%E8%A7%A3%E9%A1%8C%E7%AD%86%E8%A8%98/","title":"Sliding Window 解題筆記"},{"content":"2021年12月5日，我從台北桃園機場離境，我心想這次離境，是真的跟台灣的暖冬、還有輕鬆的日子告別，重回尋找工作的循環。\n前陣子跟學生時期打工的店長敘舊，我們那天在一個DevOps的活動會場，他指著一本「到日本當工程師」的書說，你也該出本書，就叫嫁到巴黎當人妻工程師，人妻那邊畫掉，他補充道。 我覺得也是挺可愛的，因此想說不妨將這段過程寫下來，或許記錄下總能有點用。\n才剛落地不久，就被滿心準備迎接我的男友傳染了感冒。冬天的歐洲大概就是這樣歡迎旅客的。\n雖說出發前給自己打了很多強心針，洗腦式的跟自己說一定可以找到dev/eng類的工作，但在假期期間落地，總還是不免想拖延到聖誕節結束（或更久）。恰巧的是，剛好有個朋友詢問在歐洲工作的事。 時運就是這麼剛好，彷彿命運說著\n 喔拜託、你已經休息夠久了！趕快動起來！\n 稍微看了一下現在就業市場的情況與自己的技能點分佈，應該花一些時間可以找到一份backend的工作。只不過不滿足於現況的我，想著是否能突破web的領域，做一些別的domain的事\u0026hellip; 因此，如果剛好有人看到這篇文章，歡迎推薦時下的新技術、或新工具:)\n","date":"2021-12-12T15:55:38+01:00","image":"https://miyaya.github.io/p/%E7%A7%BB%E5%B1%85%E5%B7%B4%E9%BB%8E/IMG_6777_hu5a493c1cc10e930f43983d9a43ec72a4_1670907_120x120_fill_q75_box_smart1.jpeg","permalink":"https://miyaya.github.io/p/%E7%A7%BB%E5%B1%85%E5%B7%B4%E9%BB%8E/","title":"移居巴黎"}]